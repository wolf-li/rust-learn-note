# 变量与不可变性

## 变量基础知识

1. 在 Rust 中，变量声明使用 let 关键字
2. Rust 支持变量类型推导，可以显示指定变量类型：`let x: i32 = 5;`
3. 变量命名使用蛇形命名（Snake Case）[^1]，而枚举和结构体使用帕斯卡命名（Pascal Case）[^2]
4. 强制类型转换 Casting a value to a different type
5. 打印变量（{} {:?} 特质，基础类型默认实现）
    * `println!("val: {}",x)`
    * `println!("val: {x}")`
6. 默认情况下，变量是不可变的（常见于函数式编程）
7. 声明变量时，在变量前添加 mut 关键字，就是可变的

不可变性是 Rust 实现可靠性和安全性的关键。

迫使开发者思考程序状态变化，并明确哪些部分的程序是可能变化的。

不可变性可以防止一类常见错误如：数据竞争和并发。

## 隐藏（shadowing variables）

Rust 允许隐藏一个变量，可以声明一个与现有变量相同名的新变量，从而有效的隐藏前一个变量。

可以改变值
可以改变类型
可以改变可变性

```rust
let x = 4;
let x = x + 4;
println!("{}", x);

// 结果
8
```

shadow 和把变量标记为 mut 时不一样的：
如果不适用 let 关键字，重新给变量赋值编译器会报错
使用 let 声明的同名新变量，也是不可变得
使用 let 声明的同名新变量，它的类型可以与之前不同

```rust
let x = 4;
let x = x + 4;
let x = x.to_string();
// println 必须要有占位符
println!("{}",x);
```

## 语法糖总结

* 不可变默认  
写 `let x = 1;` 等价于 `let x: i32 = 1;`,编译器帮你推类型，也默认不可变。
* 可变糖 mut  
`let mut x = 1;` 才是“可变绑定”的简写；去掉 `mut` 就拒绝后续赋值。
* 解构糖  
```rust
let (a, b) = (1, 2);
let Point { x, y } = pt;
```
都是模式匹配语法糖，一次拆出多个值。
* 忽略糖 _  
`let _ = foo();` 强制“丢弃返回值”，告诉编译器“我故意不用”。
* 重绑定/遮蔽（shadow）  
同一作用域重复 `let x = ...` 并不是赋值，而是新变量遮住旧变量，名字相同，类型可完全不同——这被很多人当成“语法糖式重定义”。

{{#playground  ../code/chapter2/2_1.rs}}

[^1]: 蛇形命名规则：单词全部小写，单词之间用下划线 _ 连接。例子：user_name  
[^2]: 帕斯卡命名规则：每个单词首字母大写，其余小写，不用下划线或空格。例子：UserName   
